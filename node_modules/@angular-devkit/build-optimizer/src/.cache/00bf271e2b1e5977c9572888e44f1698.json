{"remainingRequest":"D:\\FaceStyler\\Angular 5\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\FaceStyler\\Angular 5\\node_modules\\ack-angular-webcam\\webcam.component.js","dependencies":[{"path":"D:\\FaceStyler\\Angular 5\\node_modules\\ack-angular-webcam\\webcam.component.js","mtime":1526272989860},{"path":"D:\\FaceStyler\\Angular 5\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1526273107412},{"path":"D:\\FaceStyler\\Angular 5\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1526272959702}],"contextDependencies":[],"result":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar core_1 = require(\"@angular/core\");\nvar platform_browser_1 = require(\"@angular/platform-browser\");\nvar videoHelp_1 = require(\"./videoHelp\");\nvar template = \"<video id=\\\"video\\\" *ngIf=\\\"(isSupportUserMedia||isSupportWebRTC)\\\" autoplay=\\\"\\\" playsinline=\\\"\\\">Video stream not available</video>\";\nvar WebCamComponent = /*@__PURE__*/ (function () {\n    function WebCamComponent(sanitizer, element) {\n        this.sanitizer = sanitizer;\n        this.element = element;\n        this.isSupportUserMedia = false;\n        this.isSupportWebRTC = false;\n        this.isFallback = false;\n        this.sets = { element: { width: 0, height: 0 } };\n        this.mime = 'image/jpeg';\n        this.useParentWidthHeight = false;\n        this.success = new core_1.EventEmitter();\n        this.refChange = new core_1.EventEmitter();\n        this.errorChange = new core_1.EventEmitter();\n        this.catcher = new core_1.EventEmitter();\n    }\n    WebCamComponent.prototype.ngOnInit = function () {\n        this.isSupportUserMedia = videoHelp_1.getMedia() != null ? true : false;\n        this.isSupportUserMedia = false;\n        this.isSupportWebRTC = !!(videoHelp_1.browser.mediaDevices && videoHelp_1.browser.mediaDevices.getUserMedia);\n    };\n    WebCamComponent.prototype.ngAfterViewInit = function () {\n        var _this = this;\n        this.applyDefaults();\n        setTimeout(function () { return _this.afterInitCycles(); }, 0);\n    };\n    WebCamComponent.prototype.ngOnChanges = function (changes) {\n        if (!this.initComplete)\n            return;\n        if (changes.facingMode\n            || changes.videoDevice\n            || changes.videoDeviceId) {\n            this.redraw(); //restart\n        }\n        if (changes.reflect) {\n            this.applyReflect();\n        }\n    };\n    WebCamComponent.prototype.ngOnDestroy = function () {\n        this.observer.disconnect();\n        window.removeEventListener('resize', this.onResize);\n        this.stop();\n    };\n    WebCamComponent.prototype.play = function () {\n        return this.redraw();\n    };\n    WebCamComponent.prototype.stop = function () {\n        var vid = this.getVideoElm();\n        if (vid && vid.pause) {\n            vid.pause();\n        }\n        if (this.stream) {\n            this.stream.getTracks().forEach(function (track) { return track.stop(); });\n        }\n    };\n    WebCamComponent.prototype.redraw = function () {\n        this.stop();\n        this.startCapturingVideo();\n    };\n    WebCamComponent.prototype.afterInitCycles = function () {\n        var _this = this;\n        var media = videoHelp_1.getMedia();\n        // Older browsers might not implement mediaDevices at all, so we set an empty object first\n        if ((videoHelp_1.browser.mediaDevices === undefined) && !!media) {\n            videoHelp_1.browser.mediaDevices = {};\n        }\n        // Some browsers partially implement mediaDevices. We can't just assign an object\n        // with getUserMedia as it would overwrite existing properties.\n        // Here, we will just add the getUserMedia property if it's missing.\n        var getUserMediaUndefined = (videoHelp_1.browser.mediaDevices && videoHelp_1.browser.mediaDevices.getUserMedia === undefined) && !!media;\n        if (getUserMediaUndefined) {\n            videoHelp_1.browser.mediaDevices.getUserMedia = function (constraints) {\n                return new Promise(function (resolve, reject) {\n                    var userMedia = media.call(videoHelp_1.browser, constraints, resolve, reject);\n                    if (userMedia.then) {\n                        userMedia.then(function (stream) { return _this.applyStream(stream); });\n                    }\n                })\n                    .catch(function (err) { return _this.catchError(err); });\n            };\n        }\n        this.initComplete = true;\n        //deprecated. Use angular hash template referencing and @ViewChild\n        setTimeout(function () { return _this.refChange.emit(_this); }, 0);\n        this.createVideoResizer();\n        this.startCapturingVideo()\n            .then(function () { return setTimeout(function () { return _this.resize(); }, 10); })\n            .catch(function (err) { return _this.catchError(err); });\n    };\n    WebCamComponent.prototype.applyReflect = function () {\n        var videoElm = this.getVideoElm();\n        if (!videoElm)\n            return;\n        if (this.reflect) {\n            videoElm.style.transform = \"scaleX(-1)\";\n        }\n        else {\n            videoElm.style.transform = \"scaleX(1)\";\n        }\n    };\n    WebCamComponent.prototype.applyStream = function (stream) {\n        var videoElm = this.getVideoElm();\n        videoElm.srcObject = stream;\n        this.applyReflect();\n    };\n    WebCamComponent.prototype.createVideoResizer = function () {\n        var _this = this;\n        this.observer = new MutationObserver(function () { return _this.resize(); });\n        var config = {\n            attributes: true,\n            childList: true,\n            characterData: true\n            //,subtree: true\n        };\n        this.observer.observe(this.element.nativeElement, config);\n        this.onResize = function () { return _this.resize(); };\n        window.addEventListener('resize', this.onResize);\n    };\n    WebCamComponent.prototype.applyDefaults = function () {\n        this.options = this.options || {};\n        this.options.fallbackSrc = this.options.fallbackSrc || 'jscam_canvas_only.swf';\n        this.options.fallbackMode = this.options.fallbackMode || 'callback';\n        this.options.fallbackQuality = this.options.fallbackQuality || 200;\n        this.isFallback = this.options.fallback || (!this.isSupportUserMedia && !this.isSupportWebRTC && this.options.fallbackSrc) ? true : false;\n        if (!this.options.video && !this.options.audio) {\n            this.options.video = true;\n        }\n    };\n    WebCamComponent.prototype.onWebRTC = function () {\n        var _this = this;\n        var promise = Promise.resolve(null);\n        return this.promiseVideoOptions()\n            .then(function (options) {\n            _this.options.video = options;\n            return _this.setWebcam(_this.options);\n        });\n    };\n    WebCamComponent.prototype.promiseVideoOptions = function () {\n        var promise = Promise.resolve();\n        var videoOptions = {};\n        if (this.options.video && isOb(this.options.video)) {\n            Object.assign(videoOptions, this.options.video);\n            if (videoOptions.width && isOb(videoOptions.width) && !Object.keys(videoOptions.width).length) {\n                delete videoOptions.width;\n            }\n            if (videoOptions.height && isOb(videoOptions.height) && !Object.keys(videoOptions.height).length) {\n                delete videoOptions.height;\n            }\n        }\n        if (this.facingMode) {\n            videoOptions.facingMode = this.facingMode; //{exact:this.facingMode}\n        }\n        if (this.videoDeviceId) {\n            //videoOptions.deviceId = {exact:this.videoDeviceId}\n            videoOptions.deviceId = this.videoDeviceId;\n        }\n        else if (this.videoDevice) {\n            //videoOptions.deviceId = {exact:this.videoDevice.deviceId}\n            videoOptions.deviceId = this.videoDevice.deviceId;\n        }\n        return promise.then(function () { return videoOptions; });\n    };\n    //old method name (deprecated)\n    //old method name (deprecated)\n    WebCamComponent.prototype.resizeVideo =\n        //old method name (deprecated)\n        function (maxAttempts) {\n            if (maxAttempts === void 0) {\n                maxAttempts = 4;\n            }\n            return this.resize(maxAttempts);\n        };\n    WebCamComponent.prototype.resize = function (maxAttempts) {\n        var _this = this;\n        if (maxAttempts === void 0) {\n            maxAttempts = 4;\n        }\n        var video = this.getVideoElm();\n        if (!video)\n            return;\n        video.style.position = 'absolute';\n        var elm = this.useParentWidthHeight ? this.element.nativeElement.parentNode : this.element.nativeElement;\n        var width = this.options.width || parseInt(elm.offsetWidth, 10);\n        var height = this.options.height || parseInt(elm.offsetHeight, 10);\n        if (!width || !height) {\n            width = 320;\n            height = 240;\n        }\n        setTimeout(function () {\n            video.width = width;\n            video.height = height;\n            _this.sets.element.width = width;\n            _this.sets.element.height = height;\n            video.style.position = 'static';\n            //now that we set a width and height, it may need another adjustment if it pushed percent based items around\n            var resizeAgain = (!_this.options.width && width != parseInt(elm.offsetWidth, 10)) || (!_this.options.height && height != parseInt(elm.offsetHeight, 10));\n            if (resizeAgain && maxAttempts) {\n                _this.resize(--maxAttempts);\n            }\n        }, 1);\n    };\n    WebCamComponent.prototype.getVideoDimensions = function (video) {\n        video = video || this.getVideoElm();\n        var dim = { width: 0, height: 0 };\n        if (video.videoWidth) {\n            dim.width = video.videoWidth;\n            dim.height = video.videoHeight;\n        }\n        else {\n            dim.width = this.options.width || parseInt(this.element.nativeElement.offsetWidth, 10);\n            dim.height = this.options.height || parseInt(this.element.nativeElement.offsetHeight, 10);\n        }\n        if (!dim.width)\n            dim.width = 320;\n        if (!dim.height)\n            dim.height = 240;\n        return dim;\n    };\n    WebCamComponent.prototype.getVideoElm = function () {\n        var native = this.element.nativeElement;\n        var elmType = this.isFallback ? 'object' : 'video';\n        return native.getElementsByTagName(elmType)[0];\n    };\n    WebCamComponent.prototype.setWebcam = function (options) {\n        var _this = this;\n        return this.promiseStreamByVidOptions(options)\n            .then(function (stream) {\n            _this.applyStream(stream);\n            _this.processSuccess(stream);\n            _this.stream = stream;\n            return stream;\n        })\n            .catch(function (err) { return _this.catchError(err); });\n    };\n    WebCamComponent.prototype.catchError = function (err) {\n        this.errorChange.emit(this.error = err);\n        this.catcher.emit(err);\n        if (!this.errorChange.observers.length && !this.catcher.observers.length) {\n            return Promise.reject(err); //if no error subscriptions promise need to continue to be Uncaught\n        }\n    };\n    WebCamComponent.prototype.promiseStreamByVidOptions = function (optionObject) {\n        return new Promise(function (resolve, reject) {\n            try {\n                videoHelp_1.browser.mediaDevices.getUserMedia(optionObject)\n                    .then(function (stream) { return resolve(stream); })\n                    .catch(function (objErr) { return reject(objErr); });\n            }\n            catch (e) {\n                reject(e);\n            }\n        });\n    };\n    WebCamComponent.prototype.processSuccess = function (stream) {\n        if (this.isFallback) {\n            this.setupFallback();\n        }\n        else {\n            this.success.emit(stream);\n        }\n    };\n    /**\n     * Start capturing video stream\n     * @returns {void}\n     */\n    /**\n       * Start capturing video stream\n       * @returns {void}\n       */\n    WebCamComponent.prototype.startCapturingVideo = /**\n       * Start capturing video stream\n       * @returns {void}\n       */\n        function () {\n            if (!this.isFallback && this.isSupportWebRTC) {\n                return this.onWebRTC();\n            }\n            return Promise.resolve(this.processSuccess());\n        };\n    WebCamComponent.prototype.getCanvas = function () {\n        return document.createElement('canvas');\n    };\n    /** returns promise . @mime - null=png . Also accepts image/jpeg */\n    /** returns promise . @mime - null=png . Also accepts image/jpeg */\n    WebCamComponent.prototype.getBase64 = /** returns promise . @mime - null=png . Also accepts image/jpeg */\n        function (mime) {\n            if (this.isFallback) {\n                return this.flashPlayer.captureBase64(mime || this.mime);\n                //return this.getFallbackBase64(mime)\n            }\n            else {\n                var canvas = this.getCanvas();\n                var video = this.getVideoElm();\n                this.setCanvasWidth(canvas, video);\n                var ctx = canvas.getContext('2d');\n                if (this.reflect) {\n                    ctx.translate(canvas.width, 0);\n                    ctx.scale(-1, 1);\n                }\n                ctx.drawImage(video, 0, 0);\n                return Promise.resolve(canvas.toDataURL(mime));\n            }\n        };\n    WebCamComponent.prototype.setCanvasWidth = function (canvas, video) {\n        var di = this.getVideoDimensions(video);\n        canvas = canvas || this.getCanvas();\n        canvas.width = di.width;\n        canvas.height = di.height;\n    };\n    /** older browsers (IE11) cannot dynamically apply most attribute changes to object elements. Use this method during fallback */\n    /** older browsers (IE11) cannot dynamically apply most attribute changes to object elements. Use this method during fallback */\n    WebCamComponent.prototype.createVidElmOb = /** older browsers (IE11) cannot dynamically apply most attribute changes to object elements. Use this method during fallback */\n        function () {\n            var rtnElm = document.createElement('object');\n            rtnElm.innerHTML = 'Video stream not available';\n            rtnElm.setAttribute('type', 'application/x-shockwave-flash');\n            rtnElm.setAttribute('data', this.options.fallbackSrc);\n            var paramVar = document.createElement('param');\n            paramVar.setAttribute('name', 'FlashVars');\n            paramVar.setAttribute('value', 'mode=callback&amp;quality=200');\n            rtnElm.appendChild(paramVar);\n            paramVar = document.createElement('param');\n            paramVar.setAttribute('name', 'allowScriptAccess');\n            paramVar.setAttribute('value', 'always');\n            rtnElm.appendChild(paramVar);\n            paramVar = document.createElement('param');\n            paramVar.setAttribute('name', 'movie');\n            paramVar.setAttribute('value', this.options.fallbackSrc);\n            rtnElm.appendChild(paramVar);\n            var obs = this.element.nativeElement.getElementsByTagName('object');\n            if (obs.length) {\n                this.element.nativeElement.removeChild(obs[0]);\n            }\n            this.element.nativeElement.appendChild(rtnElm);\n            return rtnElm;\n        };\n    WebCamComponent.prototype.setupFallback = function () {\n        this.isFallback = true;\n        var vidElm = this.getVideoElm() || this.createVidElmOb();\n        this.flashPlayer = new videoHelp_1.Fallback(vidElm);\n    };\n    /** single image to FormData */\n    /** single image to FormData */\n    WebCamComponent.prototype.captureAsFormData = /** single image to FormData */\n        function (options) {\n            options = options || {};\n            return this.getBase64(options.mime)\n                .then(function (base64) { return videoHelp_1.dataUriToFormData(base64, { fileName: options.fileName }); });\n        };\n    WebCamComponent.prototype.dataUriToFormData = function (base64, options) {\n        return videoHelp_1.dataUriToFormData(base64, { fileName: options.fileName });\n    };\n    WebCamComponent.decorators = [\n        { type: core_1.Component, args: [{\n                    selector: 'ack-webcam',\n                    template: template,\n                    exportAs: 'webcam'\n                },] },\n    ];\n    WebCamComponent.propDecorators = {\n        \"videoDevice\": [{ type: core_1.Input },],\n        \"videoDeviceId\": [{ type: core_1.Input },],\n        \"reflect\": [{ type: core_1.Input },],\n        \"facingMode\": [{ type: core_1.Input },],\n        \"mime\": [{ type: core_1.Input },],\n        \"useParentWidthHeight\": [{ type: core_1.Input },],\n        \"options\": [{ type: core_1.Input },],\n        \"success\": [{ type: core_1.Output },],\n        \"ref\": [{ type: core_1.Input },],\n        \"refChange\": [{ type: core_1.Output },],\n        \"error\": [{ type: core_1.Input },],\n        \"errorChange\": [{ type: core_1.Output },],\n        \"catcher\": [{ type: core_1.Output, args: ['catch',] },],\n    };\n    return WebCamComponent;\n}());\nexports.WebCamComponent = WebCamComponent;\nfunction isOb(v) {\n    return typeof (v) === 'object';\n}\n",null]}